{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _slicedToArray = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _toConsumableArray = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\n\nvar buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\n\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n\nvar Base_1 = __importDefault(require(\"./Base\"));\n\nvar treeify_1 = __importDefault(require(\"treeify\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\n\n\nvar MerkleTree = /*#__PURE__*/function (_Base_1$default) {\n  _inherits(MerkleTree, _Base_1$default);\n\n  var _super = _createSuper(MerkleTree);\n\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  function MerkleTree(leaves) {\n    var _this;\n\n    var hashFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256_1.default;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, MerkleTree);\n\n    _this = _super.call(this);\n    _this.duplicateOdd = false;\n    _this.hashLeaves = false;\n    _this.isBitcoinTree = false;\n    _this.leaves = [];\n    _this.layers = [];\n    _this.sortLeaves = false;\n    _this.sortPairs = false;\n    _this.sort = false;\n    _this.fillDefaultHash = null;\n    _this.isBitcoinTree = !!options.isBitcoinTree;\n    _this.hashLeaves = !!options.hashLeaves;\n    _this.sortLeaves = !!options.sortLeaves;\n    _this.sortPairs = !!options.sortPairs;\n\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === 'function') {\n        _this.fillDefaultHash = options.fillDefaultHash;\n      } else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n        _this.fillDefaultHash = function (idx, hashFn) {\n          return options.fillDefaultHash;\n        };\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n\n    _this.sort = !!options.sort;\n\n    if (_this.sort) {\n      _this.sortLeaves = true;\n      _this.sortPairs = true;\n    }\n\n    _this.duplicateOdd = !!options.duplicateOdd;\n    _this.hashFn = _this._bufferifyFn(hashFn);\n\n    _this.processLeaves(leaves);\n\n    return _this;\n  }\n\n  _createClass(MerkleTree, [{\n    key: \"processLeaves\",\n    value: function processLeaves(leaves) {\n      var _this2 = this;\n\n      if (this.hashLeaves) {\n        leaves = leaves.map(function (leaf) {\n          return _this2.hashFn(leaf);\n        });\n      }\n\n      this.leaves = leaves.map(function (leaf) {\n        return _this2.bufferify(leaf);\n      });\n\n      if (this.sortLeaves) {\n        this.leaves = this.leaves.sort(Buffer.compare);\n      }\n\n      if (this.fillDefaultHash) {\n        for (var i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n          if (i >= this.leaves.length) {\n            this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n          }\n        }\n      }\n\n      this.layers = [this.leaves];\n\n      this._createHashes(this.leaves);\n    }\n  }, {\n    key: \"_createHashes\",\n    value: function _createHashes(nodes) {\n      while (nodes.length > 1) {\n        var layerIndex = this.layers.length;\n        this.layers.push([]);\n\n        for (var i = 0; i < nodes.length; i += 2) {\n          if (i + 1 === nodes.length) {\n            if (nodes.length % 2 === 1) {\n              var _data = nodes[nodes.length - 1];\n              var _hash = _data; // is bitcoin tree\n\n              if (this.isBitcoinTree) {\n                // Bitcoin method of duplicating the odd ending nodes\n                _data = Buffer.concat([buffer_reverse_1.default(_data), buffer_reverse_1.default(_data)]);\n                _hash = this.hashFn(_data);\n                _hash = buffer_reverse_1.default(this.hashFn(_hash));\n                this.layers[layerIndex].push(_hash);\n                continue;\n              } else {\n                if (this.duplicateOdd) {// continue with creating layer\n                } else {\n                  // push copy of hash and continue iteration\n                  this.layers[layerIndex].push(nodes[i]);\n                  continue;\n                }\n              }\n            }\n          }\n\n          var left = nodes[i];\n          var right = i + 1 === nodes.length ? left : nodes[i + 1];\n          var data = null;\n          var combined = null;\n\n          if (this.isBitcoinTree) {\n            combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n          } else {\n            combined = [left, right];\n          }\n\n          if (this.sortPairs) {\n            combined.sort(Buffer.compare);\n          }\n\n          data = Buffer.concat(combined);\n          var hash = this.hashFn(data); // double hash if bitcoin tree\n\n          if (this.isBitcoinTree) {\n            hash = buffer_reverse_1.default(this.hashFn(hash));\n          }\n\n          this.layers[layerIndex].push(hash);\n        }\n\n        nodes = this.layers[layerIndex];\n      }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n\n  }, {\n    key: \"addLeaf\",\n    value: function addLeaf(leaf) {\n      var shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (shouldHash) {\n        leaf = this.hashFn(leaf);\n      }\n\n      this.processLeaves([].concat(_toConsumableArray(this.leaves), [leaf]));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n\n  }, {\n    key: \"addLeaves\",\n    value: function addLeaves(leaves) {\n      var _this3 = this;\n\n      var shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (shouldHash) {\n        leaves = leaves.map(function (leaf) {\n          return _this3.hashFn(leaf);\n        });\n      }\n\n      this.processLeaves([].concat(_toConsumableArray(this.leaves), _toConsumableArray(leaves)));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n\n  }, {\n    key: \"getLeaves\",\n    value: function getLeaves(values) {\n      var _this4 = this;\n\n      if (Array.isArray(values)) {\n        if (this.hashLeaves) {\n          values = values.map(function (value) {\n            return _this4.hashFn(value);\n          });\n\n          if (this.sortLeaves) {\n            values = values.sort(Buffer.compare);\n          }\n        }\n\n        return this.leaves.filter(function (leaf) {\n          return _this4._bufferIndexOf(values, leaf) !== -1;\n        });\n      }\n\n      return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n\n  }, {\n    key: \"getLeaf\",\n    value: function getLeaf(index) {\n      if (index < 0 || index > this.leaves.length - 1) {\n        return Buffer.from([]);\n      }\n\n      return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n\n  }, {\n    key: \"getLeafIndex\",\n    value: function getLeafIndex(target) {\n      target = this.bufferify(target);\n      var leaves = this.getLeaves();\n\n      for (var i = 0; i < leaves.length; i++) {\n        var leaf = leaves[i];\n\n        if (leaf.equals(target)) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n\n  }, {\n    key: \"getLeafCount\",\n    value: function getLeafCount() {\n      return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n\n  }, {\n    key: \"getHexLeaves\",\n    value: function getHexLeaves() {\n      var _this5 = this;\n\n      return this.leaves.map(function (leaf) {\n        return _this5.bufferToHex(leaf);\n      });\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n\n  }, {\n    key: \"getLayers\",\n    value:\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    function getLayers() {\n      return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n\n  }, {\n    key: \"getHexLayers\",\n    value: function getHexLayers() {\n      var _this6 = this;\n\n      return this.layers.reduce(function (acc, item) {\n        if (Array.isArray(item)) {\n          acc.push(item.map(function (value) {\n            return _this6.bufferToHex(value);\n          }));\n        } else {\n          acc.push(item);\n        }\n\n        return acc;\n      }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n\n  }, {\n    key: \"getLayersFlat\",\n    value: function getLayersFlat() {\n      var layers = this.layers.reduce(function (acc, item) {\n        if (Array.isArray(item)) {\n          acc.unshift.apply(acc, _toConsumableArray(item));\n        } else {\n          acc.unshift(item);\n        }\n\n        return acc;\n      }, []);\n      layers.unshift(Buffer.from([0]));\n      return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n\n  }, {\n    key: \"getHexLayersFlat\",\n    value: function getHexLayersFlat() {\n      var _this7 = this;\n\n      return this.getLayersFlat().map(function (layer) {\n        return _this7.bufferToHex(layer);\n      });\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n\n  }, {\n    key: \"getLayerCount\",\n    value: function getLayerCount() {\n      return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      if (this.layers.length === 0) {\n        return Buffer.from([]);\n      }\n\n      return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n\n  }, {\n    key: \"getProof\",\n    value: function getProof(leaf, index) {\n      if (typeof leaf === 'undefined') {\n        throw new Error('leaf is required');\n      }\n\n      leaf = this.bufferify(leaf);\n      var proof = [];\n\n      if (!Number.isInteger(index)) {\n        index = -1;\n\n        for (var i = 0; i < this.leaves.length; i++) {\n          if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n            index = i;\n          }\n        }\n      }\n\n      if (index <= -1) {\n        return [];\n      }\n\n      for (var _i = 0; _i < this.layers.length; _i++) {\n        var layer = this.layers[_i];\n        var isRightNode = index % 2;\n        var pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && _i < this.layers.length - 1 // Proof Generation for Bitcoin Trees\n        ? index // Proof Generation for Non-Bitcoin Trees\n        : index + 1;\n\n        if (pairIndex < layer.length) {\n          proof.push({\n            position: isRightNode ? 'left' : 'right',\n            data: layer[pairIndex]\n          });\n        } // set index to parent index\n\n\n        index = index / 2 | 0;\n      }\n\n      return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n\n  }, {\n    key: \"getHexProof\",\n    value: function getHexProof(leaf, index) {\n      var _this8 = this;\n\n      return this.getProof(leaf, index).map(function (item) {\n        return _this8.bufferToHex(item.data);\n      });\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n\n  }, {\n    key: \"getPositionalHexProof\",\n    value: function getPositionalHexProof(leaf, index) {\n      var _this9 = this;\n\n      return this.getProof(leaf, index).map(function (item) {\n        return [item.position === 'left' ? 0 : 1, _this9.bufferToHex(item.data)];\n      });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n\n  }, {\n    key: \"getProofIndices\",\n    value:\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    function getProofIndices(treeIndices, depth) {\n      var leafCount = Math.pow(2, depth);\n      var maximalIndices = new Set();\n\n      var _iterator = _createForOfIteratorHelper(treeIndices),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          var x = leafCount + index;\n\n          while (x > 1) {\n            maximalIndices.add(x ^ 1);\n            x = x / 2 | 0;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var a = treeIndices.map(function (index) {\n        return leafCount + index;\n      });\n      var b = Array.from(maximalIndices).sort(function (a, b) {\n        return a - b;\n      }).reverse();\n      maximalIndices = a.concat(b);\n      var redundantIndices = new Set();\n      var proof = [];\n\n      var _iterator2 = _createForOfIteratorHelper(maximalIndices),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _index = _step2.value;\n\n          if (!redundantIndices.has(_index)) {\n            proof.push(_index);\n\n            while (_index > 1) {\n              redundantIndices.add(_index);\n              if (!redundantIndices.has(_index ^ 1)) break;\n              _index = _index / 2 | 0;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return proof.filter(function (index) {\n        return !treeIndices.includes(index - leafCount);\n      });\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n\n  }, {\n    key: \"getMultiProof\",\n    value: function getMultiProof(tree, indices) {\n      var _this10 = this;\n\n      if (!indices) {\n        indices = tree;\n        tree = this.getLayersFlat();\n\n        if (!indices.every(Number.isInteger)) {\n          var els = indices;\n\n          if (this.sortPairs) {\n            els = els.sort(Buffer.compare);\n          }\n\n          var ids = els.map(function (el) {\n            return _this10._bufferIndexOf(_this10.leaves, el);\n          }).sort(function (a, b) {\n            return a === b ? 0 : a > b ? 1 : -1;\n          });\n\n          if (!ids.every(function (idx) {\n            return idx !== -1;\n          })) {\n            throw new Error('Element does not exist in Merkle tree');\n          }\n\n          var hashes = [];\n          var proof = [];\n          var nextIds = [];\n\n          for (var i = 0; i < this.layers.length; i++) {\n            var layer = this.layers[i];\n\n            for (var j = 0; j < ids.length; j++) {\n              var idx = ids[j];\n\n              var pairElement = this._getPairNode(layer, idx);\n\n              hashes.push(layer[idx]);\n\n              if (pairElement) {\n                proof.push(pairElement);\n              }\n\n              nextIds.push(idx / 2 | 0);\n            }\n\n            ids = nextIds.filter(function (value, i, self) {\n              return self.indexOf(value) === i;\n            });\n            nextIds = [];\n          }\n\n          return proof.filter(function (value) {\n            return !hashes.includes(value);\n          });\n        }\n      }\n\n      return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map(function (index) {\n        return tree[index];\n      });\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n\n  }, {\n    key: \"getHexMultiProof\",\n    value: function getHexMultiProof(tree, indices) {\n      var _this11 = this;\n\n      return this.getMultiProof(tree, indices).map(function (x) {\n        return _this11.bufferToHex(x);\n      });\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n\n  }, {\n    key: \"getProofFlags\",\n    value: function getProofFlags(leaves, proofs) {\n      var _this12 = this;\n\n      if (!Array.isArray(leaves) || leaves.length <= 0) {\n        throw new Error('Invalid Inputs!');\n      }\n\n      var ids;\n\n      if (leaves.every(Number.isInteger)) {\n        ids = leaves.sort(function (a, b) {\n          return a === b ? 0 : a > b ? 1 : -1;\n        }); // Indices where passed\n      } else {\n        ids = leaves.map(function (el) {\n          return _this12._bufferIndexOf(_this12.leaves, el);\n        }).sort(function (a, b) {\n          return a === b ? 0 : a > b ? 1 : -1;\n        });\n      }\n\n      if (!ids.every(function (idx) {\n        return idx !== -1;\n      })) {\n        throw new Error('Element does not exist in Merkle tree');\n      }\n\n      var _proofs = proofs.map(function (item) {\n        return _this12.bufferify(item);\n      });\n\n      var tested = [];\n      var flags = [];\n\n      var _loop = function _loop(index) {\n        var layer = _this12.layers[index];\n        ids = ids.reduce(function (ids, idx) {\n          var skipped = tested.includes(layer[idx]);\n\n          if (!skipped) {\n            var pairElement = _this12._getPairNode(layer, idx);\n\n            var proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n\n            pairElement && flags.push(!proofUsed);\n            tested.push(layer[idx]);\n            tested.push(pairElement);\n          }\n\n          ids.push(idx / 2 | 0);\n          return ids;\n        }, []);\n      };\n\n      for (var index = 0; index < this.layers.length; index++) {\n        _loop(index);\n      }\n\n      return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(proof, targetNode, root) {\n      var hash = this.bufferify(targetNode);\n      root = this.bufferify(root);\n\n      if (!Array.isArray(proof) || !targetNode || !root) {\n        return false;\n      }\n\n      for (var i = 0; i < proof.length; i++) {\n        var node = proof[i];\n        var data = null;\n        var isLeftNode = null; // case for when proof is hex values only\n\n        if (typeof node === 'string') {\n          data = this.bufferify(node);\n          isLeftNode = true;\n        } else if (Array.isArray(node)) {\n          isLeftNode = node[0] === 0;\n          data = this.bufferify(node[1]);\n        } else if (Buffer.isBuffer(node)) {\n          data = node;\n          isLeftNode = true;\n        } else if (node instanceof Object) {\n          data = this.bufferify(node.data);\n          isLeftNode = node.position === 'left';\n        } else {\n          throw new Error('Expected node to be of type string or object');\n        }\n\n        var buffers = [];\n\n        if (this.isBitcoinTree) {\n          buffers.push(buffer_reverse_1.default(hash));\n          buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n          hash = this.hashFn(Buffer.concat(buffers));\n          hash = buffer_reverse_1.default(this.hashFn(hash));\n        } else {\n          if (this.sortPairs) {\n            if (Buffer.compare(hash, data) === -1) {\n              buffers.push(hash, data);\n              hash = this.hashFn(Buffer.concat(buffers));\n            } else {\n              buffers.push(data, hash);\n              hash = this.hashFn(Buffer.concat(buffers));\n            }\n          } else {\n            buffers.push(hash);\n            buffers[isLeftNode ? 'unshift' : 'push'](data);\n            hash = this.hashFn(Buffer.concat(buffers));\n          }\n        }\n      }\n\n      return Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} indices - Leave indices\n     * @param {Buffer[]} leaves - Leaf values at indices.\n     * @param {Number} depth - Tree depth\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const depth = tree.getDepth()\n     *const indices = [2, 5, 6]\n     *const proofLeaves = indices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, indices, proofLeaves, depth, proof)\n     *```\n     */\n\n  }, {\n    key: \"verifyMultiProof\",\n    value: function verifyMultiProof(root, indices, leaves, depth, proof) {\n      var _this13 = this;\n\n      root = this.bufferify(root);\n      leaves = leaves.map(function (leaf) {\n        return _this13.bufferify(leaf);\n      });\n      proof = proof.map(function (leaf) {\n        return _this13.bufferify(leaf);\n      });\n      var tree = {};\n\n      var _iterator3 = _createForOfIteratorHelper(this._zip(indices, leaves)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              _index2 = _step3$value[0],\n              leaf = _step3$value[1];\n\n          tree[Math.pow(2, depth) + _index2] = leaf;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(this._zip(this.getProofIndices(indices, depth), proof)),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              _index3 = _step4$value[0],\n              proofitem = _step4$value[1];\n\n          tree[_index3] = proofitem;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var indexqueue = Object.keys(tree).map(function (value) {\n        return +value;\n      }).sort(function (a, b) {\n        return a - b;\n      });\n      indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n      var i = 0;\n\n      while (i < indexqueue.length) {\n        var index = indexqueue[i];\n\n        if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n          var pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n\n          if (this.sortPairs) {\n            pair = pair.sort(Buffer.compare);\n          }\n\n          tree[index / 2 | 0] = this.hashFn(Buffer.concat(pair));\n          indexqueue.push(index / 2 | 0);\n        }\n\n        i += 1;\n      }\n\n      return !indices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n\n  }, {\n    key: \"getDepth\",\n    value: function getDepth() {\n      return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n\n  }, {\n    key: \"getLayersAsObject\",\n    value: function getLayersAsObject() {\n      var _this14 = this;\n\n      var layers = this.getLayers().map(function (layer) {\n        return layer.map(function (value) {\n          return _this14.bufferToHex(value, false);\n        });\n      });\n      var objs = [];\n\n      for (var i = 0; i < layers.length; i++) {\n        var arr = [];\n\n        for (var j = 0; j < layers[i].length; j++) {\n          var obj = _defineProperty({}, layers[i][j], null);\n\n          if (objs.length) {\n            obj[layers[i][j]] = {};\n            var a = objs.shift();\n            var akey = Object.keys(a)[0];\n            obj[layers[i][j]][akey] = a[akey];\n\n            if (objs.length) {\n              var b = objs.shift();\n              var bkey = Object.keys(b)[0];\n              obj[layers[i][j]][bkey] = b[bkey];\n            }\n          }\n\n          arr.push(obj);\n        }\n\n        objs.push.apply(objs, arr);\n      }\n\n      return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n\n  }, {\n    key: \"resetTree\",\n    value:\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    function resetTree() {\n      this.leaves = [];\n      this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n\n  }, {\n    key: \"_getPairNode\",\n    value: function _getPairNode(layer, idx) {\n      var pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n\n      if (pairIdx < layer.length) {\n        return layer[pairIdx];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n\n  }, {\n    key: \"_toTreeString\",\n    value: function _toTreeString() {\n      var obj = this.getLayersAsObject();\n      return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._toTreeString();\n    }\n  }], [{\n    key: \"marshalLeaves\",\n    value: function marshalLeaves(leaves) {\n      return JSON.stringify(leaves.map(function (leaf) {\n        return MerkleTree.bufferToHex(leaf);\n      }), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n\n  }, {\n    key: \"unmarshalLeaves\",\n    value: function unmarshalLeaves(jsonStr) {\n      var parsed = null;\n\n      if (typeof jsonStr === 'string') {\n        parsed = JSON.parse(jsonStr);\n      } else if (jsonStr instanceof Object) {\n        parsed = jsonStr;\n      } else {\n        throw new Error('Expected type of string or object');\n      }\n\n      if (!parsed) {\n        return [];\n      }\n\n      if (!Array.isArray(parsed)) {\n        throw new Error('Expected JSON string to be array');\n      }\n\n      return parsed.map(function (leaf) {\n        return MerkleTree.bufferify(leaf);\n      });\n    }\n  }, {\n    key: \"marshalProof\",\n    value: function marshalProof(proof) {\n      var json = proof.map(function (item) {\n        if (typeof item === 'string') {\n          return item;\n        }\n\n        if (Buffer.isBuffer(item)) {\n          return MerkleTree.bufferToHex(item);\n        }\n\n        return {\n          position: item.position,\n          data: MerkleTree.bufferToHex(item.data)\n        };\n      });\n      return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n\n  }, {\n    key: \"unmarshalProof\",\n    value: function unmarshalProof(jsonStr) {\n      var parsed = null;\n\n      if (typeof jsonStr === 'string') {\n        parsed = JSON.parse(jsonStr);\n      } else if (jsonStr instanceof Object) {\n        parsed = jsonStr;\n      } else {\n        throw new Error('Expected type of string or object');\n      }\n\n      if (!parsed) {\n        return [];\n      }\n\n      if (!Array.isArray(parsed)) {\n        throw new Error('Expected JSON string to be array');\n      }\n\n      return parsed.map(function (item) {\n        if (typeof item === 'string') {\n          return MerkleTree.bufferify(item);\n        } else if (item instanceof Object) {\n          return {\n            position: item.position,\n            data: MerkleTree.bufferify(item.data)\n          };\n        } else {\n          throw new Error('Expected item to be of type string or object');\n        }\n      });\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(proof, targetNode, root) {\n      var hashFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sha256_1.default;\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var tree = new MerkleTree([], hashFn, options);\n      return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n\n  }, {\n    key: \"getMultiProof\",\n    value: function getMultiProof(tree, indices) {\n      var t = new MerkleTree([]);\n      return t.getMultiProof(tree, indices);\n    }\n  }]);\n\n  return MerkleTree;\n}(Base_1.default);\n\nexports.MerkleTree = MerkleTree;\n\nif (typeof window !== 'undefined') {\n  ;\n  window.MerkleTree = MerkleTree;\n}\n\nexports.default = MerkleTree;","map":{"version":3,"sources":["/home/ellika/Web3/node_modules/merkletreejs/dist/MerkleTree.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleTree","buffer_reverse_1","require","sha256_1","Base_1","treeify_1","leaves","hashFn","default","options","duplicateOdd","hashLeaves","isBitcoinTree","layers","sortLeaves","sortPairs","sort","fillDefaultHash","Buffer","isBuffer","idx","Error","_bufferifyFn","processLeaves","map","leaf","bufferify","compare","i","Math","pow","ceil","log2","length","push","_createHashes","nodes","layerIndex","data","hash","concat","left","right","combined","shouldHash","values","Array","isArray","filter","_bufferIndexOf","index","from","target","getLeaves","equals","bufferToHex","reduce","acc","item","unshift","getLayersFlat","layer","getLayers","getRoot","proof","Number","isInteger","isRightNode","pairIndex","position","getProof","treeIndices","depth","leafCount","maximalIndices","Set","x","add","a","b","reverse","redundantIndices","has","includes","tree","indices","every","els","ids","el","hashes","nextIds","j","pairElement","_getPairNode","self","indexOf","getProofIndices","_log2","getMultiProof","proofs","_proofs","tested","flags","skipped","proofUsed","targetNode","root","node","isLeftNode","buffers","_zip","proofitem","indexqueue","keys","slice","hasOwnProperty","call","pair","objs","arr","obj","shift","akey","bkey","pairIdx","getLayersAsObject","asTree","_toTreeString","JSON","stringify","jsonStr","parsed","parse","json","verify","t","window"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleTree = void 0;\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\nconst treeify_1 = __importDefault(require(\"treeify\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base_1.default {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    constructor(leaves, hashFn = sha256_1.default, options = {}) {\n        super();\n        this.duplicateOdd = false;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === 'function') {\n                this.fillDefaultHash = options.fillDefaultHash;\n            }\n            else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n                this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n            }\n            else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        this.hashFn = this._bufferifyFn(hashFn);\n        this.processLeaves(leaves);\n    }\n    processLeaves(leaves) {\n        if (this.hashLeaves) {\n            leaves = leaves.map(leaf => this.hashFn(leaf));\n        }\n        this.leaves = leaves.map(leaf => this.bufferify(leaf));\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n                if (i >= this.leaves.length) {\n                    this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n                }\n            }\n        }\n        this.layers = [this.leaves];\n        this._createHashes(this.leaves);\n    }\n    _createHashes(nodes) {\n        while (nodes.length > 1) {\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            for (let i = 0; i < nodes.length; i += 2) {\n                if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        let data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            data = Buffer.concat([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]);\n                            hash = this.hashFn(data);\n                            hash = buffer_reverse_1.default(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        }\n                        else {\n                            if (this.duplicateOdd) {\n                                // continue with creating layer\n                            }\n                            else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let data = null;\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(Buffer.compare);\n                }\n                data = Buffer.concat(combined);\n                let hash = this.hashFn(data);\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse_1.default(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n    addLeaf(leaf, shouldHash = false) {\n        if (shouldHash) {\n            leaf = this.hashFn(leaf);\n        }\n        this.processLeaves([...this.leaves, leaf]);\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n    addLeaves(leaves, shouldHash = false) {\n        if (shouldHash) {\n            leaves = leaves.map(leaf => this.hashFn(leaf));\n        }\n        this.processLeaves([...this.leaves, ...leaves]);\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(value => this.hashFn(value));\n                if (this.sortLeaves) {\n                    values = values.sort(Buffer.compare);\n                }\n            }\n            return this.leaves.filter(leaf => this._bufferIndexOf(values, leaf) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n    getLeaf(index) {\n        if (index < 0 || index > this.leaves.length - 1) {\n            return Buffer.from([]);\n        }\n        return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n    getLeafIndex(target) {\n        target = this.bufferify(target);\n        const leaves = this.getLeaves();\n        for (let i = 0; i < leaves.length; i++) {\n            const leaf = leaves[i];\n            if (leaf.equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n    getLeafCount() {\n        return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n    getHexLeaves() {\n        return this.leaves.map(leaf => this.bufferToHex(leaf));\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n    static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n    static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(leaf => MerkleTree.bufferify(leaf));\n    }\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    getLayers() {\n        return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n    getHexLayers() {\n        return this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(value => this.bufferToHex(value)));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n    getLayersFlat() {\n        const layers = this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            }\n            else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(Buffer.from([0]));\n        return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n    getHexLayersFlat() {\n        return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n    getLayerCount() {\n        return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    getRoot() {\n        if (this.layers.length === 0) {\n            return Buffer.from([]);\n        }\n        return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    getProof(leaf, index) {\n        if (typeof leaf === 'undefined') {\n            throw new Error('leaf is required');\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for (let i = 0; i < this.leaves.length; i++) {\n                if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        for (let i = 0; i < this.layers.length; i++) {\n            const layer = this.layers[i];\n            const isRightNode = index % 2;\n            const pairIndex = (isRightNode ? index - 1\n                : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1\n                    // Proof Generation for Bitcoin Trees\n                    ? index\n                    // Proof Generation for Non-Bitcoin Trees\n                    : index + 1);\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? 'left' : 'right',\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            index = (index / 2) | 0;\n        }\n        return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n    getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n    getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => {\n            return [\n                item.position === 'left' ? 0 : 1,\n                this.bufferToHex(item.data)\n            ];\n        });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n    static marshalProof(proof) {\n        const json = proof.map(item => {\n            if (typeof item === 'string') {\n                return item;\n            }\n            if (Buffer.isBuffer(item)) {\n                return MerkleTree.bufferToHex(item);\n            }\n            return {\n                position: item.position,\n                data: MerkleTree.bufferToHex(item.data)\n            };\n        });\n        return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n    static unmarshalProof(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(item => {\n            if (typeof item === 'string') {\n                return MerkleTree.bufferify(item);\n            }\n            else if (item instanceof Object) {\n                return {\n                    position: item.position,\n                    data: MerkleTree.bufferify(item.data)\n                };\n            }\n            else {\n                throw new Error('Expected item to be of type string or object');\n            }\n        });\n    }\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    getProofIndices(treeIndices, depth) {\n        const leafCount = Math.pow(2, depth);\n        let maximalIndices = new Set();\n        for (const index of treeIndices) {\n            let x = leafCount + index;\n            while (x > 1) {\n                maximalIndices.add(x ^ 1);\n                x = (x / 2) | 0;\n            }\n        }\n        const a = treeIndices.map(index => leafCount + index);\n        const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices) {\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while (index > 1) {\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1))\n                        break;\n                    index = (index / 2) | 0;\n                }\n            }\n        }\n        return proof.filter(index => {\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n    getMultiProof(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n            if (!indices.every(Number.isInteger)) {\n                let els = indices;\n                if (this.sortPairs) {\n                    els = els.sort(Buffer.compare);\n                }\n                let ids = els.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n                if (!ids.every((idx) => idx !== -1)) {\n                    throw new Error('Element does not exist in Merkle tree');\n                }\n                const hashes = [];\n                const proof = [];\n                let nextIds = [];\n                for (let i = 0; i < this.layers.length; i++) {\n                    const layer = this.layers[i];\n                    for (let j = 0; j < ids.length; j++) {\n                        const idx = ids[j];\n                        const pairElement = this._getPairNode(layer, idx);\n                        hashes.push(layer[idx]);\n                        if (pairElement) {\n                            proof.push(pairElement);\n                        }\n                        nextIds.push((idx / 2) | 0);\n                    }\n                    ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n                    nextIds = [];\n                }\n                return proof.filter((value) => !hashes.includes(value));\n            }\n        }\n        return this.getProofIndices(indices, this._log2((tree.length / 2) | 0)).map(index => tree[index]);\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n    getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n    getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error('Invalid Inputs!');\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        }\n        else {\n            ids = leaves.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx) => idx !== -1)) {\n            throw new Error('Element does not exist in Merkle tree');\n        }\n        const _proofs = proofs.map(item => this.bufferify(item));\n        const tested = [];\n        const flags = [];\n        for (let index = 0; index < this.layers.length; index++) {\n            const layer = this.layers[index];\n            ids = ids.reduce((ids, idx) => {\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this._getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                ids.push((idx / 2) | 0);\n                return ids;\n            }, []);\n        }\n        return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            }\n            else if (Array.isArray(node)) {\n                isLeftNode = (node[0] === 0);\n                data = this.bufferify(node[1]);\n            }\n            else if (Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            }\n            else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = (node.position === 'left');\n            }\n            else {\n                throw new Error('Expected node to be of type string or object');\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse_1.default(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n                hash = this.hashFn(Buffer.concat(buffers));\n                hash = buffer_reverse_1.default(this.hashFn(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(Buffer.concat(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(Buffer.concat(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashFn(Buffer.concat(buffers));\n                }\n            }\n        }\n        return Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} indices - Leave indices\n     * @param {Buffer[]} leaves - Leaf values at indices.\n     * @param {Number} depth - Tree depth\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const depth = tree.getDepth()\n     *const indices = [2, 5, 6]\n     *const proofLeaves = indices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, indices, proofLeaves, depth, proof)\n     *```\n     */\n    verifyMultiProof(root, indices, leaves, depth, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const tree = {};\n        for (const [index, leaf] of this._zip(indices, leaves)) {\n            tree[(Math.pow(2, depth)) + index] = leaf;\n        }\n        for (const [index, proofitem] of this._zip(this.getProofIndices(indices, depth), proof)) {\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while (i < indexqueue.length) {\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                let pair = [tree[index - (index % 2)], tree[index - (index % 2) + 1]];\n                if (this.sortPairs) {\n                    pair = pair.sort(Buffer.compare);\n                }\n                tree[(index / 2) | 0] = this.hashFn(Buffer.concat(pair));\n                indexqueue.push((index / 2) | 0);\n            }\n            i += 1;\n        }\n        return !indices.length || (({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root));\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n    getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n    static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n        const tree = new MerkleTree([], hashFn, options);\n        return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n    static getMultiProof(tree, indices) {\n        const t = new MerkleTree([]);\n        return t.getMultiProof(tree, indices);\n    }\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    resetTree() {\n        this.leaves = [];\n        this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n    _getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n    _toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n    toString() {\n        return this._toTreeString();\n    }\n}\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleTree = MerkleTree;\n}\nexports.default = MerkleTree;\n"]},"metadata":{},"sourceType":"script"}