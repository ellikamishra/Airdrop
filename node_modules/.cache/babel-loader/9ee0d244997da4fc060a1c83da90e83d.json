{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _toConsumableArray = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/ellika/Web3/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleMountainRange = void 0;\n\nvar Base_1 = __importDefault(require(\"./Base\"));\n\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\")); // @credit: https://github.com/wanseob/solidity-mmr\n\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\n\n\nvar MerkleMountainRange = /*#__PURE__*/function (_Base_1$default) {\n  _inherits(MerkleMountainRange, _Base_1$default);\n\n  var _super = _createSuper(MerkleMountainRange);\n\n  function MerkleMountainRange() {\n    var _this;\n\n    var hashFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : sha256_1.default;\n    var leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var hashLeafFn = arguments.length > 2 ? arguments[2] : undefined;\n    var peakBaggingFn = arguments.length > 3 ? arguments[3] : undefined;\n    var hashBranchFn = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, MerkleMountainRange);\n\n    _this = _super.call(this);\n    _this.root = Buffer.alloc(0);\n    _this.size = 0;\n    _this.width = 0;\n    _this.hashes = {};\n    _this.data = {};\n    leaves = leaves.map(_this.bufferify);\n    _this.hashFn = _this._bufferifyFn(hashFn);\n    _this.hashLeafFn = hashLeafFn;\n    _this.peakBaggingFn = peakBaggingFn;\n    _this.hashBranchFn = hashBranchFn;\n\n    var _iterator = _createForOfIteratorHelper(leaves),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var leaf = _step.value;\n\n        _this.append(leaf);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return _this;\n  }\n  /**\n   * @desc This only stores the hashed value of the leaf.\n   * If you need to retrieve the detail data later, use a map to store them.\n   */\n\n\n  _createClass(MerkleMountainRange, [{\n    key: \"append\",\n    value: function append(data) {\n      data = this.bufferify(data);\n      var dataHash = this.hashFn(data);\n      var dataHashHex = this.bufferToHex(dataHash);\n\n      if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n        this.data[dataHashHex] = data;\n      }\n\n      var leaf = this.hashLeaf(this.size + 1, dataHash);\n      this.hashes[this.size + 1] = leaf;\n      this.width += 1; // find peaks for enlarged tree\n\n      var peakIndexes = this.getPeakIndexes(this.width); // the right most peak's value is the new size of the updated tree\n\n      this.size = this.getSize(this.width); // starting from the left-most peak, get all peak hashes\n\n      var peaks = [];\n\n      for (var i = 0; i < peakIndexes.length; i++) {\n        peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n      } // update the tree root hash\n\n\n      this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n\n  }, {\n    key: \"hashLeaf\",\n    value: function hashLeaf(index, dataHash) {\n      dataHash = this.bufferify(dataHash);\n\n      if (this.hashLeafFn) {\n        return this.bufferify(this.hashLeafFn(index, dataHash));\n      }\n\n      return this.hashFn(Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n\n  }, {\n    key: \"hashBranch\",\n    value: function hashBranch(index, left, right) {\n      if (this.hashBranchFn) {\n        return this.bufferify(this.hashBranchFn(index, left, right));\n      }\n\n      return this.hashFn(Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n  }, {\n    key: \"getPeaks\",\n    value: function getPeaks() {\n      var peakIndexes = this.getPeakIndexes(this.width);\n      var peaks = [];\n\n      for (var i = 0; i < peakIndexes.length; i++) {\n        peaks[i] = this.hashes[peakIndexes[i]];\n      }\n\n      return peaks;\n    }\n  }, {\n    key: \"getLeafIndex\",\n    value: function getLeafIndex(width) {\n      if (width % 2 === 1) {\n        return this.getSize(width);\n      }\n\n      return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n\n  }, {\n    key: \"getPeakIndexes\",\n    value: function getPeakIndexes(width) {\n      var numPeaks = this.numOfPeaks(width);\n      var peakIndexes = [];\n      var count = 0;\n      var size = 0;\n\n      for (var i = 255; i > 0; i--) {\n        if ((width & 1 << i - 1) !== 0) {\n          // peak exists\n          size = size + (1 << i) - 1;\n          peakIndexes[count++] = size;\n\n          if (peakIndexes.length >= numPeaks) {\n            break;\n          }\n        }\n      }\n\n      if (count !== peakIndexes.length) {\n        throw new Error('invalid bit calculation');\n      }\n\n      return peakIndexes;\n    }\n  }, {\n    key: \"numOfPeaks\",\n    value: function numOfPeaks(width) {\n      var bits = width;\n      var num = 0;\n\n      while (bits > 0) {\n        if (bits % 2 === 1) {\n          num++;\n        }\n\n        bits = bits >> 1;\n      }\n\n      return num;\n    }\n  }, {\n    key: \"peakBagging\",\n    value: function peakBagging(width, peaks) {\n      var size = this.getSize(width);\n\n      if (this.numOfPeaks(width) !== peaks.length) {\n        throw new Error('received invalid number of peaks');\n      }\n\n      if (width === 0 && !peaks.length) {\n        return Buffer.alloc(0);\n      }\n\n      if (this.peakBaggingFn) {\n        return this.bufferify(this.peakBaggingFn(size, peaks));\n      }\n\n      return this.hashFn(Buffer.concat([this.bufferify(size)].concat(_toConsumableArray(peaks.map(this.bufferify)))));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize(width) {\n      return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      return this.root;\n    }\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n\n  }, {\n    key: \"mountainHeight\",\n    value: function mountainHeight(size) {\n      var height = 1;\n\n      while (1 << height <= size + height) {\n        height++;\n      }\n\n      return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n\n  }, {\n    key: \"heightAt\",\n    value: function heightAt(index) {\n      var reducedIndex = index;\n      var peakIndex = 0;\n      var height = 0; // if an index has a left mountain then subtract the mountain\n\n      while (reducedIndex > peakIndex) {\n        reducedIndex -= (1 << height) - 1;\n        height = this.mountainHeight(reducedIndex);\n        peakIndex = (1 << height) - 1;\n      } // index is on the right slope\n\n\n      return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n\n  }, {\n    key: \"isLeaf\",\n    value: function isLeaf(index) {\n      return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(index) {\n      var left = index - (1 << this.heightAt(index) - 1);\n      var right = index - 1;\n\n      if (left === right) {\n        throw new Error('not a parent');\n      }\n\n      return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n\n  }, {\n    key: \"getMerkleProof\",\n    value: function getMerkleProof(index) {\n      if (index > this.size) {\n        throw new Error('out of range');\n      }\n\n      if (!this.isLeaf(index)) {\n        throw new Error('not a leaf');\n      }\n\n      var root = this.root;\n      var width = this.width; // find all peaks for bagging\n\n      var peaks = this.getPeakIndexes(this.width);\n      var peakBagging = [];\n      var cursor = 0;\n\n      for (var i = 0; i < peaks.length; i++) {\n        // collect the hash of all peaks\n        peakBagging[i] = this.hashes[peaks[i]]; // find the peak which includes the target index\n\n        if (peaks[i] >= index && cursor === 0) {\n          cursor = peaks[i];\n        }\n      }\n\n      var left = 0;\n      var right = 0; // get hashes of the siblings in the mountain which the index belgons to.\n      // it moves the cursor from the summit of the mountain down to the target index\n\n      var height = this.heightAt(cursor);\n      var siblings = [];\n\n      while (cursor !== index) {\n        height--;\n\n        var _this$getChildren = this.getChildren(cursor);\n\n        var _this$getChildren2 = _slicedToArray(_this$getChildren, 2);\n\n        left = _this$getChildren2[0];\n        right = _this$getChildren2[1];\n        // move the cursor down to the left size or right size\n        cursor = index <= left ? left : right; // remaining node is the sibling\n\n        siblings[height - 1] = this.hashes[index <= left ? right : left];\n      }\n\n      return {\n        root: root,\n        width: width,\n        peakBagging: peakBagging,\n        siblings: siblings\n      };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(root, width, index, value, peaks, siblings) {\n      value = this.bufferify(value);\n      var size = this.getSize(width);\n\n      if (size < index) {\n        throw new Error('index is out of range');\n      } // check the root equals the peak bagging hash\n\n\n      if (!root.equals(this.peakBagging(width, peaks))) {\n        throw new Error('invalid root hash from the peaks');\n      } // find the mountain where the target index belongs to\n\n\n      var cursor = 0;\n      var targetPeak;\n      var peakIndexes = this.getPeakIndexes(width);\n\n      for (var i = 0; i < peakIndexes.length; i++) {\n        if (peakIndexes[i] >= index) {\n          targetPeak = peaks[i];\n          cursor = peakIndexes[i];\n          break;\n        }\n      }\n\n      if (!targetPeak) {\n        throw new Error('target not found');\n      } // find the path climbing down\n\n\n      var height = siblings.length + 1;\n      var path = new Array(height);\n      var left = 0;\n      var right = 0;\n\n      while (height > 0) {\n        // record the current cursor and climb down\n        path[--height] = cursor;\n\n        if (cursor === index) {\n          // on the leaf node. Stop climbing down\n          break;\n        } else {\n          // on the parent node. Go left or right\n          var _this$getChildren3 = this.getChildren(cursor);\n\n          var _this$getChildren4 = _slicedToArray(_this$getChildren3, 2);\n\n          left = _this$getChildren4[0];\n          right = _this$getChildren4[1];\n          cursor = index > left ? right : left;\n          continue;\n        }\n      } // calculate the summit hash climbing up again\n\n\n      var node;\n\n      while (height < path.length) {\n        // move cursor\n        cursor = path[height];\n\n        if (height === 0) {\n          // cusor is on the leaf\n          node = this.hashLeaf(cursor, this.hashFn(value));\n        } else if (cursor - 1 === path[height - 1]) {\n          // cursor is on a parent and a siblings is on the left\n          node = this.hashBranch(cursor, siblings[height - 1], node);\n        } else {\n          // cursor is on a parent and a siblings is on the right\n          node = this.hashBranch(cursor, node, siblings[height - 1]);\n        } // climb up\n\n\n        height++;\n      } // computed hash value of the summit should equal to the target peak hash\n\n\n      if (!node.equals(targetPeak)) {\n        throw new Error('hashed peak is invalid');\n      }\n\n      return true;\n    }\n  }, {\n    key: \"peaksToPeakMap\",\n    value: function peaksToPeakMap(width, peaks) {\n      var peakMap = {};\n      var bitIndex = 0;\n      var peakRef = 0;\n      var count = peaks.length;\n\n      for (var height = 1; height <= 32; height++) {\n        // index starts from the right most bit\n        bitIndex = 32 - height;\n        peakRef = 1 << height - 1;\n\n        if ((width & peakRef) !== 0) {\n          peakMap[bitIndex] = peaks[--count];\n        } else {\n          peakMap[bitIndex] = 0;\n        }\n      }\n\n      if (count !== 0) {\n        throw new Error('invalid number of peaks');\n      }\n\n      return peakMap;\n    }\n  }, {\n    key: \"peakMapToPeaks\",\n    value: function peakMapToPeaks(width, peakMap) {\n      var arrLength = this.numOfPeaks(width);\n      var peaks = new Array(arrLength);\n      var count = 0;\n\n      for (var i = 0; i < 32; i++) {\n        if (peakMap[i] !== 0) {\n          peaks[count++] = peakMap[i];\n        }\n      }\n\n      if (count !== arrLength) {\n        throw new Error('invalid number of peaks');\n      }\n\n      return peaks;\n    }\n  }, {\n    key: \"peakUpdate\",\n    value: function peakUpdate(width, prevPeakMap, itemHash) {\n      var nextPeakMap = {};\n      var newWidth = width + 1;\n      var cursorIndex = this.getLeafIndex(newWidth);\n      var cursorNode = this.hashLeaf(cursorIndex, itemHash);\n      var bitIndex = 0;\n      var peakRef = 0;\n      var prevPeakExist = false;\n      var nextPeakExist = false;\n      var obtained = false;\n\n      for (var height = 1; height <= 32; height++) {\n        // index starts from the right most bit\n        bitIndex = 32 - height;\n\n        if (obtained) {\n          nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n        } else {\n          peakRef = 1 << height - 1;\n          prevPeakExist = (width & peakRef) !== 0;\n          nextPeakExist = (newWidth & peakRef) !== 0; // get new cursor node with hashing the peak and the current cursor\n\n          cursorIndex++;\n\n          if (prevPeakExist) {\n            cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n          } // if new peak exists for the bit index\n\n\n          if (nextPeakExist) {\n            // if prev peak exists for the bit index\n            if (prevPeakExist) {\n              nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            } else {\n              nextPeakMap[bitIndex] = cursorNode;\n            }\n\n            obtained = true;\n          } else {\n            nextPeakMap[bitIndex] = 0;\n          }\n        }\n      }\n\n      return nextPeakMap;\n    }\n  }, {\n    key: \"rollUp\",\n    value: function rollUp(root, width, peaks, itemHashes) {\n      // check the root equals the peak bagging hash\n      if (!root.equals(this.peakBagging(width, peaks))) {\n        throw new Error('invalid root hash from the peaks');\n      }\n\n      var tmpWidth = width;\n      var tmpPeakMap = this.peaksToPeakMap(width, peaks);\n\n      for (var i = 0; i < itemHashes.length; i++) {\n        tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n        tmpWidth++;\n      }\n\n      return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n\n  }, {\n    key: \"_getOrCreateNode\",\n    value: function _getOrCreateNode(index) {\n      if (index > this.size) {\n        throw new Error('out of range');\n      }\n\n      if (!this.hashes[index]) {\n        var _this$getChildren5 = this.getChildren(index),\n            _this$getChildren6 = _slicedToArray(_this$getChildren5, 2),\n            leftIndex = _this$getChildren6[0],\n            rightIndex = _this$getChildren6[1];\n\n        var leftHash = this._getOrCreateNode(leftIndex);\n\n        var rightHash = this._getOrCreateNode(rightIndex);\n\n        this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n      }\n\n      return this.hashes[index];\n    }\n  }]);\n\n  return MerkleMountainRange;\n}(Base_1.default);\n\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;","map":{"version":3,"sources":["/home/ellika/Web3/node_modules/merkletreejs/dist/MerkleMountainRange.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleMountainRange","Base_1","require","sha256_1","hashFn","default","leaves","hashLeafFn","peakBaggingFn","hashBranchFn","root","Buffer","alloc","size","width","hashes","data","map","bufferify","_bufferifyFn","leaf","append","dataHash","dataHashHex","bufferToHex","hashLeaf","peakIndexes","getPeakIndexes","getSize","peaks","i","length","_getOrCreateNode","peakBagging","index","concat","left","right","numPeaks","numOfPeaks","count","Error","bits","num","getRoot","height","reducedIndex","peakIndex","mountainHeight","heightAt","isLeaf","cursor","siblings","getChildren","equals","targetPeak","path","Array","node","hashBranch","peakMap","bitIndex","peakRef","arrLength","prevPeakMap","itemHash","nextPeakMap","newWidth","cursorIndex","getLeafIndex","cursorNode","prevPeakExist","nextPeakExist","obtained","itemHashes","tmpWidth","tmpPeakMap","peaksToPeakMap","peakUpdate","peakMapToPeaks","leftIndex","rightIndex","leftHash","rightHash"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleMountainRange = void 0;\nconst Base_1 = __importDefault(require(\"./Base\"));\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n        super();\n        this.root = Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this._bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves) {\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */\n    append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n    hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n    hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n    getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for (let i = 255; i > 0; i--) {\n            if ((width & (1 << (i - 1))) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error('invalid bit calculation');\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while (bits > 0) {\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error('received invalid number of peaks');\n        }\n        if (width === 0 && !peaks.length) {\n            return Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n    getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n    getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n    mountainHeight(size) {\n        let height = 1;\n        while (1 << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n    heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n    isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n    getChildren(index) {\n        const left = index - (1 << (this.heightAt(index) - 1));\n        const right = index - 1;\n        if (left === right) {\n            throw new Error('not a parent');\n        }\n        return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n    getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error('not a leaf');\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for (let i = 0; i < peaks.length; i++) {\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while (cursor !== index) {\n            height--;\n            ([left, right] = this.getChildren(cursor));\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error('index is out of range');\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for (let i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error('target not found');\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while (height > 0) {\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                // on the leaf node. Stop climbing down\n                break;\n            }\n            else {\n                // on the parent node. Go left or right\n                ([left, right] = this.getChildren(cursor));\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while (height < path.length) {\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            }\n            else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            }\n            else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error('hashed peak is invalid');\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            }\n            else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error('invalid number of peaks');\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for (let i = 0; i < 32; i++) {\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error('invalid number of peaks');\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            }\n            else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    }\n                    else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                }\n                else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for (let i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n    _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;\n"]},"metadata":{},"sourceType":"script"}